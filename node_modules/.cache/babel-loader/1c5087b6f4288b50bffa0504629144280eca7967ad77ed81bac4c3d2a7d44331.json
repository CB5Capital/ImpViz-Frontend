{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback, useState } from 'react';\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionAttempts, setConnectionAttempts] = useState(0);\n  const [lastError, setLastError] = useState(null);\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const mountedRef = useRef(true);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n      try {\n        const messageStr = JSON.stringify(message);\n        wsRef.current.send(messageStr);\n        console.log('📤 Sent WebSocket message:', messageStr);\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        setLastError(`Send error: ${error.message}`);\n      }\n    } else {\n      console.warn('⚠️ WebSocket is not connected. Cannot send message:', message);\n    }\n  }, []);\n  useEffect(() => {\n    mountedRef.current = true;\n    let localWs = null;\n    let localReconnectTimeout = null;\n    let pingInterval = null;\n    const connect = () => {\n      if (!mountedRef.current) return;\n      try {\n        console.log(`🔌 Attempting WebSocket connection to ${url}`);\n        setConnectionState('connecting');\n        localWs = new WebSocket(url);\n        wsRef.current = localWs;\n        localWs.onopen = () => {\n          if (!mountedRef.current) return;\n          console.log('✅ WebSocket connected successfully!');\n          setIsConnected(true);\n          setConnectionState('connected');\n          setConnectionAttempts(0);\n          setLastError(null);\n\n          // Start ping interval\n          pingInterval = setInterval(() => {\n            if (localWs.readyState === WebSocket.OPEN) {\n              try {\n                localWs.send(JSON.stringify({\n                  type: 'ping'\n                }));\n                console.log('🏓 Sent ping');\n              } catch (err) {\n                console.error('Error sending ping:', err);\n              }\n            }\n          }, 30000);\n          if (onConnect) onConnect();\n        };\n        localWs.onmessage = event => {\n          if (!mountedRef.current) return;\n          try {\n            console.log('📨 Raw message:', event.data.substring(0, 200));\n            const data = JSON.parse(event.data);\n\n            // Handle pong\n            if (data.type === 'pong') {\n              console.log('🏓 Received pong');\n              return;\n            }\n\n            // Pass to callback\n            if (onMessage) {\n              console.log('📦 Processing message with data keys:', Object.keys(data));\n              onMessage(data);\n            }\n          } catch (error) {\n            console.error('❌ Error parsing message:', error);\n          }\n        };\n        localWs.onerror = error => {\n          console.error('🔴 WebSocket error:', error);\n          setLastError('Connection error');\n          setConnectionState('error');\n        };\n        localWs.onclose = event => {\n          if (!mountedRef.current) return;\n          console.log(`🔌 WebSocket disconnected (code: ${event.code}, reason: ${event.reason})`);\n          setIsConnected(false);\n          setConnectionState('disconnected');\n\n          // Clear ping interval\n          if (pingInterval) {\n            clearInterval(pingInterval);\n            pingInterval = null;\n          }\n          if (onDisconnect) onDisconnect();\n\n          // Reconnect with exponential backoff\n          if (mountedRef.current) {\n            const attempts = connectionAttempts;\n            setConnectionAttempts(prev => prev + 1);\n            const delay = Math.min(1000 * Math.pow(2, attempts), 30000);\n            console.log(`⏱️ Reconnecting in ${delay}ms (attempt ${attempts + 1})`);\n            localReconnectTimeout = setTimeout(() => {\n              if (mountedRef.current) {\n                connect();\n              }\n            }, delay);\n          }\n        };\n      } catch (error) {\n        console.error('❌ Failed to create WebSocket:', error);\n        setConnectionState('error');\n        setLastError(error.message);\n\n        // Retry connection\n        if (mountedRef.current) {\n          localReconnectTimeout = setTimeout(() => {\n            if (mountedRef.current) {\n              connect();\n            }\n          }, 5000);\n        }\n      }\n    };\n\n    // Initial connection\n    connect();\n\n    // Cleanup\n    return () => {\n      console.log('🧹 Cleaning up WebSocket connection');\n      mountedRef.current = false;\n      if (localReconnectTimeout) {\n        clearTimeout(localReconnectTimeout);\n      }\n      if (pingInterval) {\n        clearInterval(pingInterval);\n      }\n      if (localWs) {\n        localWs.close();\n      }\n      wsRef.current = null;\n    };\n  }, [url]); // Only reconnect when URL changes\n\n  return {\n    sendMessage,\n    isConnected,\n    connectionAttempts,\n    lastError,\n    connectionState\n  };\n};\n_s(useWebSocket, \"T9MkWduQ/l+jhtTodw+OhM57LbM=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useState","useWebSocket","url","onMessage","onConnect","onDisconnect","_s","isConnected","setIsConnected","connectionAttempts","setConnectionAttempts","lastError","setLastError","connectionState","setConnectionState","wsRef","reconnectTimeoutRef","mountedRef","sendMessage","message","_wsRef$current","current","readyState","WebSocket","OPEN","messageStr","JSON","stringify","send","console","log","error","warn","localWs","localReconnectTimeout","pingInterval","connect","onopen","setInterval","type","err","onmessage","event","data","substring","parse","Object","keys","onerror","onclose","code","reason","clearInterval","attempts","prev","delay","Math","min","pow","setTimeout","clearTimeout","close"],"sources":["/Users/viktorkardvik/Code/CB5Capital/ImpViz/Frontend/TradingBarReact/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useCallback, useState } from 'react';\n\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionAttempts, setConnectionAttempts] = useState(0);\n  const [lastError, setLastError] = useState(null);\n  const [connectionState, setConnectionState] = useState('disconnected');\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const mountedRef = useRef(true);\n\n  const sendMessage = useCallback((message) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        const messageStr = JSON.stringify(message);\n        wsRef.current.send(messageStr);\n        console.log('📤 Sent WebSocket message:', messageStr);\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        setLastError(`Send error: ${error.message}`);\n      }\n    } else {\n      console.warn('⚠️ WebSocket is not connected. Cannot send message:', message);\n    }\n  }, []);\n\n  useEffect(() => {\n    mountedRef.current = true;\n    let localWs = null;\n    let localReconnectTimeout = null;\n    let pingInterval = null;\n\n    const connect = () => {\n      if (!mountedRef.current) return;\n      \n      try {\n        console.log(`🔌 Attempting WebSocket connection to ${url}`);\n        setConnectionState('connecting');\n        \n        localWs = new WebSocket(url);\n        wsRef.current = localWs;\n\n        localWs.onopen = () => {\n          if (!mountedRef.current) return;\n          \n          console.log('✅ WebSocket connected successfully!');\n          setIsConnected(true);\n          setConnectionState('connected');\n          setConnectionAttempts(0);\n          setLastError(null);\n          \n          // Start ping interval\n          pingInterval = setInterval(() => {\n            if (localWs.readyState === WebSocket.OPEN) {\n              try {\n                localWs.send(JSON.stringify({ type: 'ping' }));\n                console.log('🏓 Sent ping');\n              } catch (err) {\n                console.error('Error sending ping:', err);\n              }\n            }\n          }, 30000);\n          \n          if (onConnect) onConnect();\n        };\n\n        localWs.onmessage = (event) => {\n          if (!mountedRef.current) return;\n          \n          try {\n            console.log('📨 Raw message:', event.data.substring(0, 200));\n            const data = JSON.parse(event.data);\n            \n            // Handle pong\n            if (data.type === 'pong') {\n              console.log('🏓 Received pong');\n              return;\n            }\n            \n            // Pass to callback\n            if (onMessage) {\n              console.log('📦 Processing message with data keys:', Object.keys(data));\n              onMessage(data);\n            }\n          } catch (error) {\n            console.error('❌ Error parsing message:', error);\n          }\n        };\n\n        localWs.onerror = (error) => {\n          console.error('🔴 WebSocket error:', error);\n          setLastError('Connection error');\n          setConnectionState('error');\n        };\n\n        localWs.onclose = (event) => {\n          if (!mountedRef.current) return;\n          \n          console.log(`🔌 WebSocket disconnected (code: ${event.code}, reason: ${event.reason})`);\n          setIsConnected(false);\n          setConnectionState('disconnected');\n          \n          // Clear ping interval\n          if (pingInterval) {\n            clearInterval(pingInterval);\n            pingInterval = null;\n          }\n          \n          if (onDisconnect) onDisconnect();\n          \n          // Reconnect with exponential backoff\n          if (mountedRef.current) {\n            const attempts = connectionAttempts;\n            setConnectionAttempts(prev => prev + 1);\n            const delay = Math.min(1000 * Math.pow(2, attempts), 30000);\n            \n            console.log(`⏱️ Reconnecting in ${delay}ms (attempt ${attempts + 1})`);\n            localReconnectTimeout = setTimeout(() => {\n              if (mountedRef.current) {\n                connect();\n              }\n            }, delay);\n          }\n        };\n      } catch (error) {\n        console.error('❌ Failed to create WebSocket:', error);\n        setConnectionState('error');\n        setLastError(error.message);\n        \n        // Retry connection\n        if (mountedRef.current) {\n          localReconnectTimeout = setTimeout(() => {\n            if (mountedRef.current) {\n              connect();\n            }\n          }, 5000);\n        }\n      }\n    };\n\n    // Initial connection\n    connect();\n\n    // Cleanup\n    return () => {\n      console.log('🧹 Cleaning up WebSocket connection');\n      mountedRef.current = false;\n      \n      if (localReconnectTimeout) {\n        clearTimeout(localReconnectTimeout);\n      }\n      \n      if (pingInterval) {\n        clearInterval(pingInterval);\n      }\n      \n      if (localWs) {\n        localWs.close();\n      }\n      \n      wsRef.current = null;\n    };\n  }, [url]); // Only reconnect when URL changes\n\n  return { \n    sendMessage, \n    isConnected, \n    connectionAttempts, \n    lastError,\n    connectionState\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}