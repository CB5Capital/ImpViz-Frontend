{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback, useState } from 'react';\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  _s();\n  var _wsRef$current6;\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionAttempts, setConnectionAttempts] = useState(0);\n  const [lastError, setLastError] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const lastPongRef = useRef(Date.now());\n  const cleanup = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n    if (wsRef.current) {\n      // Remove event listeners before closing to prevent reconnection on manual close\n      wsRef.current.onopen = null;\n      wsRef.current.onmessage = null;\n      wsRef.current.onerror = null;\n      wsRef.current.onclose = null;\n      if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {\n        wsRef.current.close();\n      }\n      wsRef.current = null;\n    }\n  }, []);\n  const startPingPong = useCallback(() => {\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    lastPongRef.current = Date.now();\n    pingIntervalRef.current = setInterval(() => {\n      var _wsRef$current;\n      if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) {\n        const now = Date.now();\n\n        // Check if we've received a pong recently (within 35 seconds)\n        if (now - lastPongRef.current > 35000) {\n          console.warn('WebSocket ping timeout - forcing reconnection');\n          setLastError('Ping timeout - server not responding');\n          wsRef.current.close();\n          return;\n        }\n\n        // Send ping\n        try {\n          wsRef.current.send(JSON.stringify({\n            type: 'ping'\n          }));\n          console.log('Sent WebSocket ping');\n        } catch (error) {\n          console.error('Error sending ping:', error);\n          setLastError(`Ping send error: ${error.message}`);\n        }\n      }\n    }, 30000); // Send ping every 30 seconds\n  }, []);\n  const connect = useCallback(() => {\n    var _wsRef$current2, _wsRef$current3;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      console.log('WebSocket already connected, skipping connection attempt');\n      return;\n    }\n    if (((_wsRef$current3 = wsRef.current) === null || _wsRef$current3 === void 0 ? void 0 : _wsRef$current3.readyState) === WebSocket.CONNECTING) {\n      console.log('WebSocket already connecting, skipping connection attempt');\n      return;\n    }\n    cleanup();\n    setConnectionAttempts(prev => prev + 1);\n    console.log(`WebSocket connection attempt #${connectionAttempts + 1} to ${url}`);\n    try {\n      const ws = new WebSocket(url);\n\n      // Set a connection timeout\n      const connectionTimeout = setTimeout(() => {\n        if (ws.readyState === WebSocket.CONNECTING) {\n          console.error('WebSocket connection timeout');\n          setLastError('Connection timeout');\n          ws.close();\n        }\n      }, 10000);\n      ws.onopen = () => {\n        clearTimeout(connectionTimeout);\n        console.log(`WebSocket connected successfully on attempt #${connectionAttempts + 1}`);\n        setIsConnected(true);\n        setConnectionAttempts(0);\n        setLastError(null);\n        lastPongRef.current = Date.now();\n        startPingPong();\n        if (onConnect) onConnect();\n      };\n      ws.onmessage = event => {\n        console.log('游댯 Raw WebSocket message received:', event.data);\n        try {\n          const data = JSON.parse(event.data);\n          console.log('游릭 Parsed WebSocket data:', data);\n\n          // Handle pong responses\n          if (data.type === 'pong') {\n            lastPongRef.current = Date.now();\n            console.log('Received WebSocket pong');\n            return;\n          }\n          if (onMessage) {\n            console.log('游리 Calling onMessage callback');\n            onMessage(data);\n          } else {\n            console.warn('丘멆잺 No onMessage callback provided');\n          }\n        } catch (error) {\n          console.error('游댮 Error parsing WebSocket message:', error, 'Raw data:', event.data);\n          setLastError(`Message parse error: ${error.message}`);\n        }\n      };\n      ws.onerror = error => {\n        clearTimeout(connectionTimeout);\n        console.error('WebSocket error occurred:', {\n          error,\n          readyState: ws.readyState,\n          url: ws.url,\n          timestamp: new Date().toISOString()\n        });\n        setLastError(`WebSocket error: ${error.type || 'Unknown error'}`);\n      };\n      ws.onclose = event => {\n        clearTimeout(connectionTimeout);\n        cleanup();\n        const closeInfo = {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean,\n          timestamp: new Date().toISOString(),\n          attempt: connectionAttempts + 1\n        };\n        console.log('WebSocket disconnected:', closeInfo);\n        setIsConnected(false);\n        setLastError(`Connection closed: ${event.code} - ${event.reason || getCloseCodeDescription(event.code)}`);\n        if (onDisconnect) onDisconnect();\n\n        // Calculate reconnection delay with exponential backoff\n        const baseDelay = 1000;\n        const maxDelay = 30000;\n        const delay = Math.min(baseDelay * Math.pow(2, Math.min(connectionAttempts, 5)), maxDelay);\n        console.log(`Scheduling reconnection in ${delay}ms (attempt #${connectionAttempts + 1})`);\n        reconnectTimeoutRef.current = setTimeout(() => {\n          if (!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED) {\n            connect();\n          }\n        }, delay);\n      };\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setLastError(`Connection creation failed: ${error.message}`);\n      const delay = Math.min(5000 * Math.pow(2, Math.min(connectionAttempts, 3)), 30000);\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, delay);\n    }\n  }, [url, onMessage, onConnect, onDisconnect, connectionAttempts, cleanup, startPingPong]);\n  const getCloseCodeDescription = code => {\n    const codes = {\n      1000: 'Normal Closure',\n      1001: 'Going Away',\n      1002: 'Protocol Error',\n      1003: 'Unsupported Data',\n      1005: 'No Status Received',\n      1006: 'Abnormal Closure',\n      1007: 'Invalid frame payload data',\n      1008: 'Policy Violation',\n      1009: 'Message too big',\n      1010: 'Missing Extension',\n      1011: 'Internal Error',\n      1012: 'Service Restart',\n      1013: 'Try Again Later',\n      1015: 'TLS Handshake'\n    };\n    return codes[code] || `Unknown (${code})`;\n  };\n  const sendMessage = useCallback(message => {\n    var _wsRef$current4;\n    if (((_wsRef$current4 = wsRef.current) === null || _wsRef$current4 === void 0 ? void 0 : _wsRef$current4.readyState) === WebSocket.OPEN) {\n      try {\n        wsRef.current.send(JSON.stringify(message));\n        console.log('Sent WebSocket message:', message);\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        setLastError(`Send error: ${error.message}`);\n      }\n    } else {\n      var _wsRef$current5;\n      const state = (_wsRef$current5 = wsRef.current) === null || _wsRef$current5 === void 0 ? void 0 : _wsRef$current5.readyState;\n      const stateNames = {\n        [WebSocket.CONNECTING]: 'CONNECTING',\n        [WebSocket.OPEN]: 'OPEN',\n        [WebSocket.CLOSING]: 'CLOSING',\n        [WebSocket.CLOSED]: 'CLOSED'\n      };\n      console.warn(`WebSocket is not connected (state: ${stateNames[state] || 'UNKNOWN'}). Cannot send message:`, message);\n      setLastError(`Cannot send message - WebSocket state: ${stateNames[state] || 'UNKNOWN'}`);\n    }\n  }, []);\n  useEffect(() => {\n    connect();\n    return () => {\n      console.log('useWebSocket cleanup - component unmounting');\n      cleanup();\n    };\n  }, [connect, cleanup]);\n  return {\n    sendMessage,\n    isConnected,\n    connectionAttempts,\n    lastError,\n    connectionState: (_wsRef$current6 = wsRef.current) === null || _wsRef$current6 === void 0 ? void 0 : _wsRef$current6.readyState\n  };\n};\n_s(useWebSocket, \"DXeb6hsHloLdHWc+JrAZJUUDNjY=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useState","useWebSocket","url","onMessage","onConnect","onDisconnect","_s","_wsRef$current6","isConnected","setIsConnected","connectionAttempts","setConnectionAttempts","lastError","setLastError","wsRef","reconnectTimeoutRef","pingIntervalRef","lastPongRef","Date","now","cleanup","current","clearTimeout","clearInterval","onopen","onmessage","onerror","onclose","readyState","WebSocket","OPEN","CONNECTING","close","startPingPong","setInterval","_wsRef$current","console","warn","send","JSON","stringify","type","log","error","message","connect","_wsRef$current2","_wsRef$current3","prev","ws","connectionTimeout","setTimeout","event","data","parse","timestamp","toISOString","closeInfo","code","reason","wasClean","attempt","getCloseCodeDescription","baseDelay","maxDelay","delay","Math","min","pow","CLOSED","codes","sendMessage","_wsRef$current4","_wsRef$current5","state","stateNames","CLOSING","connectionState"],"sources":["/Users/viktorkardvik/Code/CB5Capital/ImpViz/Frontend/TradingBarReact/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useCallback, useState } from 'react';\n\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  const [isConnected, setIsConnected] = useState(false);\n  const [connectionAttempts, setConnectionAttempts] = useState(0);\n  const [lastError, setLastError] = useState(null);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const pingIntervalRef = useRef(null);\n  const lastPongRef = useRef(Date.now());\n\n  const cleanup = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n      reconnectTimeoutRef.current = null;\n    }\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n      pingIntervalRef.current = null;\n    }\n    if (wsRef.current) {\n      // Remove event listeners before closing to prevent reconnection on manual close\n      wsRef.current.onopen = null;\n      wsRef.current.onmessage = null;\n      wsRef.current.onerror = null;\n      wsRef.current.onclose = null;\n      \n      if (wsRef.current.readyState === WebSocket.OPEN || wsRef.current.readyState === WebSocket.CONNECTING) {\n        wsRef.current.close();\n      }\n      wsRef.current = null;\n    }\n  }, []);\n\n  const startPingPong = useCallback(() => {\n    if (pingIntervalRef.current) {\n      clearInterval(pingIntervalRef.current);\n    }\n    \n    lastPongRef.current = Date.now();\n    \n    pingIntervalRef.current = setInterval(() => {\n      if (wsRef.current?.readyState === WebSocket.OPEN) {\n        const now = Date.now();\n        \n        // Check if we've received a pong recently (within 35 seconds)\n        if (now - lastPongRef.current > 35000) {\n          console.warn('WebSocket ping timeout - forcing reconnection');\n          setLastError('Ping timeout - server not responding');\n          wsRef.current.close();\n          return;\n        }\n        \n        // Send ping\n        try {\n          wsRef.current.send(JSON.stringify({ type: 'ping' }));\n          console.log('Sent WebSocket ping');\n        } catch (error) {\n          console.error('Error sending ping:', error);\n          setLastError(`Ping send error: ${error.message}`);\n        }\n      }\n    }, 30000); // Send ping every 30 seconds\n  }, []);\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      console.log('WebSocket already connected, skipping connection attempt');\n      return;\n    }\n    \n    if (wsRef.current?.readyState === WebSocket.CONNECTING) {\n      console.log('WebSocket already connecting, skipping connection attempt');\n      return;\n    }\n\n    cleanup();\n    \n    setConnectionAttempts(prev => prev + 1);\n    console.log(`WebSocket connection attempt #${connectionAttempts + 1} to ${url}`);\n\n    try {\n      const ws = new WebSocket(url);\n      \n      // Set a connection timeout\n      const connectionTimeout = setTimeout(() => {\n        if (ws.readyState === WebSocket.CONNECTING) {\n          console.error('WebSocket connection timeout');\n          setLastError('Connection timeout');\n          ws.close();\n        }\n      }, 10000);\n      \n      ws.onopen = () => {\n        clearTimeout(connectionTimeout);\n        console.log(`WebSocket connected successfully on attempt #${connectionAttempts + 1}`);\n        setIsConnected(true);\n        setConnectionAttempts(0);\n        setLastError(null);\n        lastPongRef.current = Date.now();\n        \n        startPingPong();\n        \n        if (onConnect) onConnect();\n      };\n\n      ws.onmessage = (event) => {\n        console.log('游댯 Raw WebSocket message received:', event.data);\n        try {\n          const data = JSON.parse(event.data);\n          console.log('游릭 Parsed WebSocket data:', data);\n          \n          // Handle pong responses\n          if (data.type === 'pong') {\n            lastPongRef.current = Date.now();\n            console.log('Received WebSocket pong');\n            return;\n          }\n          \n          if (onMessage) {\n            console.log('游리 Calling onMessage callback');\n            onMessage(data);\n          } else {\n            console.warn('丘멆잺 No onMessage callback provided');\n          }\n        } catch (error) {\n          console.error('游댮 Error parsing WebSocket message:', error, 'Raw data:', event.data);\n          setLastError(`Message parse error: ${error.message}`);\n        }\n      };\n\n      ws.onerror = (error) => {\n        clearTimeout(connectionTimeout);\n        console.error('WebSocket error occurred:', {\n          error,\n          readyState: ws.readyState,\n          url: ws.url,\n          timestamp: new Date().toISOString()\n        });\n        setLastError(`WebSocket error: ${error.type || 'Unknown error'}`);\n      };\n\n      ws.onclose = (event) => {\n        clearTimeout(connectionTimeout);\n        cleanup();\n        \n        const closeInfo = {\n          code: event.code,\n          reason: event.reason,\n          wasClean: event.wasClean,\n          timestamp: new Date().toISOString(),\n          attempt: connectionAttempts + 1\n        };\n        \n        console.log('WebSocket disconnected:', closeInfo);\n        setIsConnected(false);\n        setLastError(`Connection closed: ${event.code} - ${event.reason || getCloseCodeDescription(event.code)}`);\n        \n        if (onDisconnect) onDisconnect();\n        \n        // Calculate reconnection delay with exponential backoff\n        const baseDelay = 1000;\n        const maxDelay = 30000;\n        const delay = Math.min(baseDelay * Math.pow(2, Math.min(connectionAttempts, 5)), maxDelay);\n        \n        console.log(`Scheduling reconnection in ${delay}ms (attempt #${connectionAttempts + 1})`);\n        \n        reconnectTimeoutRef.current = setTimeout(() => {\n          if (!wsRef.current || wsRef.current.readyState === WebSocket.CLOSED) {\n            connect();\n          }\n        }, delay);\n      };\n\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      setLastError(`Connection creation failed: ${error.message}`);\n      \n      const delay = Math.min(5000 * Math.pow(2, Math.min(connectionAttempts, 3)), 30000);\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, delay);\n    }\n  }, [url, onMessage, onConnect, onDisconnect, connectionAttempts, cleanup, startPingPong]);\n\n  const getCloseCodeDescription = (code) => {\n    const codes = {\n      1000: 'Normal Closure',\n      1001: 'Going Away',\n      1002: 'Protocol Error',\n      1003: 'Unsupported Data',\n      1005: 'No Status Received',\n      1006: 'Abnormal Closure',\n      1007: 'Invalid frame payload data',\n      1008: 'Policy Violation',\n      1009: 'Message too big',\n      1010: 'Missing Extension',\n      1011: 'Internal Error',\n      1012: 'Service Restart',\n      1013: 'Try Again Later',\n      1015: 'TLS Handshake'\n    };\n    return codes[code] || `Unknown (${code})`;\n  };\n\n  const sendMessage = useCallback((message) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      try {\n        wsRef.current.send(JSON.stringify(message));\n        console.log('Sent WebSocket message:', message);\n      } catch (error) {\n        console.error('Error sending WebSocket message:', error);\n        setLastError(`Send error: ${error.message}`);\n      }\n    } else {\n      const state = wsRef.current?.readyState;\n      const stateNames = {\n        [WebSocket.CONNECTING]: 'CONNECTING',\n        [WebSocket.OPEN]: 'OPEN',\n        [WebSocket.CLOSING]: 'CLOSING',\n        [WebSocket.CLOSED]: 'CLOSED'\n      };\n      console.warn(`WebSocket is not connected (state: ${stateNames[state] || 'UNKNOWN'}). Cannot send message:`, message);\n      setLastError(`Cannot send message - WebSocket state: ${stateNames[state] || 'UNKNOWN'}`);\n    }\n  }, []);\n\n  useEffect(() => {\n    connect();\n\n    return () => {\n      console.log('useWebSocket cleanup - component unmounting');\n      cleanup();\n    };\n  }, [connect, cleanup]);\n\n  return { \n    sendMessage, \n    isConnected, \n    connectionAttempts, \n    lastError,\n    connectionState: wsRef.current?.readyState \n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}