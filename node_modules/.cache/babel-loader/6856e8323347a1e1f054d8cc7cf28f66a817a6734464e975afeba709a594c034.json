{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useEffect, useRef, useCallback, useState } from 'react';\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  _s();\n  const [isConnected, setIsConnected] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n  const connect = useCallback(() => {\n    var _wsRef$current;\n    if (((_wsRef$current = wsRef.current) === null || _wsRef$current === void 0 ? void 0 : _wsRef$current.readyState) === WebSocket.OPEN) return;\n    try {\n      const ws = new WebSocket(url);\n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        if (onConnect) onConnect();\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n          reconnectTimeoutRef.current = null;\n        }\n      };\n      ws.onmessage = event => {\n        try {\n          const data = JSON.parse(event.data);\n          if (onMessage) onMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n      ws.onerror = error => {\n        console.error('WebSocket error:', error);\n      };\n      ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        if (onDisconnect) onDisconnect();\n        wsRef.current = null;\n        reconnectTimeoutRef.current = setTimeout(() => {\n          console.log('Attempting to reconnect...');\n          connect();\n        }, 5000);\n      };\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, 5000);\n    }\n  }, [url, onMessage, onConnect, onDisconnect]);\n  const sendMessage = useCallback(message => {\n    var _wsRef$current2;\n    if (((_wsRef$current2 = wsRef.current) === null || _wsRef$current2 === void 0 ? void 0 : _wsRef$current2.readyState) === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }, []);\n  useEffect(() => {\n    connect();\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, [connect]);\n  return {\n    sendMessage,\n    isConnected\n  };\n};\n_s(useWebSocket, \"+TDvbOSK90Q36qn6H7QfFeTiKCw=\");","map":{"version":3,"names":["useEffect","useRef","useCallback","useState","useWebSocket","url","onMessage","onConnect","onDisconnect","_s","isConnected","setIsConnected","wsRef","reconnectTimeoutRef","connect","_wsRef$current","current","readyState","WebSocket","OPEN","ws","onopen","console","log","clearTimeout","onmessage","event","data","JSON","parse","error","onerror","onclose","setTimeout","sendMessage","message","_wsRef$current2","send","stringify","warn","close"],"sources":["/Users/viktorkardvik/Code/CB5Capital/ImpViz/Frontend/TradingBarReact/src/hooks/useWebSocket.js"],"sourcesContent":["import { useEffect, useRef, useCallback, useState } from 'react';\n\nexport const useWebSocket = (url, onMessage, onConnect, onDisconnect) => {\n  const [isConnected, setIsConnected] = useState(false);\n  const wsRef = useRef(null);\n  const reconnectTimeoutRef = useRef(null);\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) return;\n\n    try {\n      const ws = new WebSocket(url);\n      \n      ws.onopen = () => {\n        console.log('WebSocket connected');\n        setIsConnected(true);\n        if (onConnect) onConnect();\n        if (reconnectTimeoutRef.current) {\n          clearTimeout(reconnectTimeoutRef.current);\n          reconnectTimeoutRef.current = null;\n        }\n      };\n\n      ws.onmessage = (event) => {\n        try {\n          const data = JSON.parse(event.data);\n          if (onMessage) onMessage(data);\n        } catch (error) {\n          console.error('Error parsing WebSocket message:', error);\n        }\n      };\n\n      ws.onerror = (error) => {\n        console.error('WebSocket error:', error);\n      };\n\n      ws.onclose = () => {\n        console.log('WebSocket disconnected');\n        setIsConnected(false);\n        if (onDisconnect) onDisconnect();\n        wsRef.current = null;\n        \n        reconnectTimeoutRef.current = setTimeout(() => {\n          console.log('Attempting to reconnect...');\n          connect();\n        }, 5000);\n      };\n\n      wsRef.current = ws;\n    } catch (error) {\n      console.error('Failed to create WebSocket connection:', error);\n      reconnectTimeoutRef.current = setTimeout(() => {\n        connect();\n      }, 5000);\n    }\n  }, [url, onMessage, onConnect, onDisconnect]);\n\n  const sendMessage = useCallback((message) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(JSON.stringify(message));\n    } else {\n      console.warn('WebSocket is not connected');\n    }\n  }, []);\n\n  useEffect(() => {\n    connect();\n\n    return () => {\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n      }\n      if (wsRef.current) {\n        wsRef.current.close();\n      }\n    };\n  }, [connect]);\n\n  return { sendMessage, isConnected };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}