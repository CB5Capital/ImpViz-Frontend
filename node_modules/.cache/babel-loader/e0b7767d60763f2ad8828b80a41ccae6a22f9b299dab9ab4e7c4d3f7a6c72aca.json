{"ast":null,"code":"export const convertSignalsToMarketFormat = signalsData => {\n  const marketData = {};\n  const signalsByMarket = signalsData.signals_by_market || {};\n  for (const [market, marketSignals] of Object.entries(signalsByMarket)) {\n    marketData[market] = {\n      Long: {\n        signals_count: 0,\n        base_strength: 0,\n        final_score: 0,\n        setup_names: [],\n        individual_signals: [],\n        adjusted_strength: 0,\n        timeframes_count: 0,\n        conviction: 0,\n        conviction_impact: 0,\n        correlation_penalty: 0,\n        signal_left_impact: 0,\n        certainty: 100,\n        conviction_penalty: 0\n      },\n      Short: {\n        signals_count: 0,\n        base_strength: 0,\n        final_score: 0,\n        setup_names: [],\n        individual_signals: [],\n        adjusted_strength: 0,\n        timeframes_count: 0,\n        conviction: 0,\n        conviction_impact: 0,\n        correlation_penalty: 0,\n        signal_left_impact: 0,\n        certainty: 100,\n        conviction_penalty: 0\n      }\n    };\n    const signals = marketSignals.signals || [];\n    const timeframesSet = {\n      Long: new Set(),\n      Short: new Set()\n    };\n    for (const signal of signals) {\n      const direction = signal.direction || 'Long';\n      if (direction in marketData[market]) {\n        const directionData = marketData[market][direction];\n        const hasSignal = signal.has_active_signal === 1 || signal.has_active_signal === true;\n        if (hasSignal) {\n          directionData.signals_count += 1;\n          directionData.base_strength += signal.signal_strength || 0;\n          const setupName = signal.setup_name || 'Unknown';\n          if (!directionData.setup_names.includes(setupName)) {\n            directionData.setup_names.push(setupName);\n          }\n          directionData.individual_signals.push(signal);\n          if (signal.timeframe) {\n            timeframesSet[direction].add(signal.timeframe);\n          }\n        }\n      }\n    }\n    for (const direction of ['Long', 'Short']) {\n      const directionData = marketData[market][direction];\n      if (directionData.signals_count > 0) {\n        directionData.timeframes_count = timeframesSet[direction].size;\n        directionData.final_score = directionData.base_strength / directionData.signals_count;\n        directionData.base_strength = directionData.final_score;\n        directionData.adjusted_strength = directionData.final_score * 2;\n        directionData.conviction = Math.min(3, Math.floor(directionData.signals_count / 2));\n        directionData.conviction_impact = directionData.conviction * 5;\n        directionData.correlation_penalty = Math.max(0, (4 - directionData.timeframes_count) * 10);\n        directionData.certainty = 100 - directionData.correlation_penalty;\n        const longStr = marketData[market].Long.adjusted_strength;\n        const shortStr = marketData[market].Short.adjusted_strength;\n        if (longStr > 10 && shortStr > 10) {\n          directionData.certainty = Math.max(0, directionData.certainty - 50);\n        }\n        directionData.conviction_penalty = directionData.conviction === 1 ? -10 : directionData.conviction === 2 ? -5 : 0;\n        directionData.final_score = (directionData.adjusted_strength + directionData.conviction_impact + directionData.certainty + directionData.signal_left_impact + directionData.conviction_penalty) / 4;\n      } else {\n        directionData.final_score = 0;\n        directionData.base_strength = 0;\n        directionData.adjusted_strength = 0;\n      }\n    }\n  }\n  return marketData;\n};\nexport const calculateFallbackScore = directionData => {\n  if (!directionData || directionData.signals_count === 0) {\n    return 0;\n  }\n  const baseStrength = (directionData.base_strength || 0) * 2;\n  const convictionImpact = directionData.conviction_impact || 0;\n  const correlationPenalty = directionData.correlation_penalty || 0;\n  const signalLeftImpact = directionData.signal_left_impact || 0;\n  const certainty = 100 - correlationPenalty;\n  const conviction = directionData.conviction || 0;\n  const convictionPenalty = conviction === 1 ? -10 : conviction === 2 ? -5 : 0;\n  return (baseStrength + convictionImpact + certainty + signalLeftImpact + convictionPenalty) / 4;\n};\nexport const processMarketData = data => {\n  if (data.type === 'error') {\n    return null;\n  }\n  const rawData = data.data || {};\n  if ('signals_by_market' in rawData) {\n    return convertSignalsToMarketFormat(rawData);\n  }\n  return rawData;\n};\nexport const getSignalColor = strength => {\n  if (strength >= 70) return '#00ff88';\n  if (strength >= 50) return '#ffaa00';\n  if (strength >= 30) return '#ff6600';\n  return '#666666';\n};\nexport const formatPercentage = value => {\n  if (value === undefined || value === null) return '0%';\n  return `${Math.round(value)}%`;\n};\nexport const formatNumber = (value, decimals = 2) => {\n  if (value === undefined || value === null) return '0';\n  return value.toFixed(decimals);\n};","map":{"version":3,"names":["convertSignalsToMarketFormat","signalsData","marketData","signalsByMarket","signals_by_market","market","marketSignals","Object","entries","Long","signals_count","base_strength","final_score","setup_names","individual_signals","adjusted_strength","timeframes_count","conviction","conviction_impact","correlation_penalty","signal_left_impact","certainty","conviction_penalty","Short","signals","timeframesSet","Set","signal","direction","directionData","hasSignal","has_active_signal","signal_strength","setupName","setup_name","includes","push","timeframe","add","size","Math","min","floor","max","longStr","shortStr","calculateFallbackScore","baseStrength","convictionImpact","correlationPenalty","signalLeftImpact","convictionPenalty","processMarketData","data","type","rawData","getSignalColor","strength","formatPercentage","value","undefined","round","formatNumber","decimals","toFixed"],"sources":["/Users/viktorkardvik/Code/CB5Capital/ImpViz/Frontend/TradingBarReact/src/utils/dataProcessing.js"],"sourcesContent":["export const convertSignalsToMarketFormat = (signalsData) => {\n  const marketData = {};\n  const signalsByMarket = signalsData.signals_by_market || {};\n  \n  for (const [market, marketSignals] of Object.entries(signalsByMarket)) {\n    marketData[market] = {\n      Long: {\n        signals_count: 0,\n        base_strength: 0,\n        final_score: 0,\n        setup_names: [],\n        individual_signals: [],\n        adjusted_strength: 0,\n        timeframes_count: 0,\n        conviction: 0,\n        conviction_impact: 0,\n        correlation_penalty: 0,\n        signal_left_impact: 0,\n        certainty: 100,\n        conviction_penalty: 0\n      },\n      Short: {\n        signals_count: 0,\n        base_strength: 0,\n        final_score: 0,\n        setup_names: [],\n        individual_signals: [],\n        adjusted_strength: 0,\n        timeframes_count: 0,\n        conviction: 0,\n        conviction_impact: 0,\n        correlation_penalty: 0,\n        signal_left_impact: 0,\n        certainty: 100,\n        conviction_penalty: 0\n      }\n    };\n    \n    const signals = marketSignals.signals || [];\n    const timeframesSet = { Long: new Set(), Short: new Set() };\n    \n    for (const signal of signals) {\n      const direction = signal.direction || 'Long';\n      \n      if (direction in marketData[market]) {\n        const directionData = marketData[market][direction];\n        \n        const hasSignal = signal.has_active_signal === 1 || signal.has_active_signal === true;\n        if (hasSignal) {\n          directionData.signals_count += 1;\n          directionData.base_strength += signal.signal_strength || 0;\n          \n          const setupName = signal.setup_name || 'Unknown';\n          if (!directionData.setup_names.includes(setupName)) {\n            directionData.setup_names.push(setupName);\n          }\n          \n          directionData.individual_signals.push(signal);\n          \n          if (signal.timeframe) {\n            timeframesSet[direction].add(signal.timeframe);\n          }\n        }\n      }\n    }\n    \n    for (const direction of ['Long', 'Short']) {\n      const directionData = marketData[market][direction];\n      \n      if (directionData.signals_count > 0) {\n        directionData.timeframes_count = timeframesSet[direction].size;\n        directionData.final_score = directionData.base_strength / directionData.signals_count;\n        directionData.base_strength = directionData.final_score;\n        directionData.adjusted_strength = directionData.final_score * 2;\n        \n        directionData.conviction = Math.min(3, Math.floor(directionData.signals_count / 2));\n        directionData.conviction_impact = directionData.conviction * 5;\n        \n        directionData.correlation_penalty = Math.max(0, (4 - directionData.timeframes_count) * 10);\n        directionData.certainty = 100 - directionData.correlation_penalty;\n        \n        const longStr = marketData[market].Long.adjusted_strength;\n        const shortStr = marketData[market].Short.adjusted_strength;\n        if (longStr > 10 && shortStr > 10) {\n          directionData.certainty = Math.max(0, directionData.certainty - 50);\n        }\n        \n        directionData.conviction_penalty = \n          directionData.conviction === 1 ? -10 : \n          directionData.conviction === 2 ? -5 : 0;\n        \n        directionData.final_score = (\n          directionData.adjusted_strength + \n          directionData.conviction_impact + \n          directionData.certainty + \n          directionData.signal_left_impact + \n          directionData.conviction_penalty\n        ) / 4;\n      } else {\n        directionData.final_score = 0;\n        directionData.base_strength = 0;\n        directionData.adjusted_strength = 0;\n      }\n    }\n  }\n  \n  return marketData;\n};\n\nexport const calculateFallbackScore = (directionData) => {\n  if (!directionData || directionData.signals_count === 0) {\n    return 0;\n  }\n  \n  const baseStrength = (directionData.base_strength || 0) * 2;\n  const convictionImpact = directionData.conviction_impact || 0;\n  const correlationPenalty = directionData.correlation_penalty || 0;\n  const signalLeftImpact = directionData.signal_left_impact || 0;\n  const certainty = 100 - correlationPenalty;\n  \n  const conviction = directionData.conviction || 0;\n  const convictionPenalty = conviction === 1 ? -10 : (conviction === 2 ? -5 : 0);\n  \n  return (baseStrength + convictionImpact + certainty + signalLeftImpact + convictionPenalty) / 4;\n};\n\nexport const processMarketData = (data) => {\n  if (data.type === 'error') {\n    return null;\n  }\n  \n  const rawData = data.data || {};\n  \n  if ('signals_by_market' in rawData) {\n    return convertSignalsToMarketFormat(rawData);\n  }\n  \n  return rawData;\n};\n\nexport const getSignalColor = (strength) => {\n  if (strength >= 70) return '#00ff88';\n  if (strength >= 50) return '#ffaa00';\n  if (strength >= 30) return '#ff6600';\n  return '#666666';\n};\n\nexport const formatPercentage = (value) => {\n  if (value === undefined || value === null) return '0%';\n  return `${Math.round(value)}%`;\n};\n\nexport const formatNumber = (value, decimals = 2) => {\n  if (value === undefined || value === null) return '0';\n  return value.toFixed(decimals);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}